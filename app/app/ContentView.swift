import SwiftUI
import PhotosUI
import UIKit

struct ContentView: View {
    @State private var selectedTab = 0

    var body: some View {
        TabView(selection: $selectedTab) {
            RecView()
                .tabItem {
                    Label("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", systemImage: "photo")
                }
                .tag(0)
            
            OutfitsView()
                .tabItem {
                    Label("–ò–∑–±—Ä–∞–Ω–Ω–æ–µ", systemImage: "heart")
                }
                .tag(1)

            WardrobeView()
                .tabItem {
                    Label("–ì–∞—Ä–¥–µ—Ä–æ–±", systemImage: "tshirt")
                }
                .tag(2)
            
        }
    }
}





struct RecView: View {
    @State private var colorType: String = ""
    @State private var imageItems: [ImageItem] = []
    @State private var isLoading = true
    @State private var selectedImageItem: ImageItem? = nil

    var body: some View {
        NavigationView {
            Group {
                if isLoading {
                    ProgressView("–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π...")
                } else if colorType.isEmpty {
                    VStack {
                        Spacer()
                        Text("–ó–¥–µ—Å—å –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è\n—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ –æ–±—Ä–∞–∑—ã")
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                        Spacer()
                    }
                } else {
                    ScrollView {
                        LazyVStack(spacing: 16) {
                            ForEach(imageItems, id: \.fileName) { item in
                                let idString = item.fileName.components(separatedBy: ".").first ?? ""
                                let lookId = Int(idString) ?? -1

                                let value = percentile(for: lookId)
//                                let value = percentile()
                                let circleColor = colorForPercentile(value)
            

                                Button(action: {
                                    selectedImageItem = item
                                }) {
                                    ZStack(alignment: .topTrailing) {
                                        Image(uiImage: item.image)
                                            .resizable()
                                            .aspectRatio(contentMode: .fit)
                                            .cornerRadius(12)
                                            .padding(.horizontal)

                                        Circle()
                                            .fill(circleColor)
                                            .frame(width: 32, height: 32)
                                            .padding(8)
                                            .offset(x: -16)
                                    }
                                }
                            }

                        }
                        .padding(.top)
                    }
                }
            }
            .navigationTitle("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏")
            .navigationBarItems(trailing:
                NavigationLink(destination: ProfileView()) {
                    Image(systemName: "person.circle")
                        .font(.title)
                }
            )
            .sheet(item: $selectedImageItem) { item in

                NavigationView {
                    ImageDetailView(imageItem: item)
                }
            }
        }
        .onAppear {
            loadColorTypeAndImages()
        }
    }
    
    func percentile(for lookId: Int) -> Double {
        let ratio = DatabaseManager.shared.calculateOwnedItemRatio(forLookId: lookId)
        let thresholds: [Double] = [1.0, 0.5, 1.0/3.0, 0.0]
        let sorted = thresholds.sorted(by: >)
//        print(lookId, ratio)
        

        for value in sorted {
            if ratio >= value {
                return value
            }
        }

        return 0.0
    }

    
//    func percentile() -> Double {
//        let values: [Double] = [1.0, 0.5, 1.0/3.0, 0.0]
//        return values.randomElement()!
//    }

    
    func colorForPercentile(_ value: Double) -> Color {
        switch value {
        case 1.0:
            return .green
        case 0.5:
            return .yellow
        case 1.0/3.0:
            return .orange
        default:
            return .red
        }
    }


    func loadColorTypeAndImages() {
        isLoading = true
        APIService.shared.fetchColorType { result in
            DispatchQueue.main.async {
                switch result {
                case .success(let response):
                    self.colorType = response.color_type.lowercased()
                    self.imageItems = loadImagesFromFolder(named: self.colorType)
                case .failure(let error):
                    print("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ color_type: \(error.localizedDescription)")
                    self.colorType = ""
                    self.imageItems = []
                }
                self.isLoading = false
            }
        }
    }

    func loadImagesFromFolder(named folderName: String) -> [ImageItem] {
        var items: [ImageItem] = []

        guard let resourcePath = Bundle.main.resourcePath else { return [] }
        let folderPath = "\(resourcePath)/looks/\(folderName)"

        do {
            let fileManager = FileManager.default
            let imagePaths = try fileManager.contentsOfDirectory(atPath: folderPath)

            for imageName in imagePaths {
                let fullPath = "\(folderPath)/\(imageName)"
                if let image = UIImage(contentsOfFile: fullPath) {
                    let item = ImageItem(image: image, fileName: imageName)
                    items.append(item)
                }
            }
        } catch {
            print("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ –ø–∞–ø–∫–∏ \(folderName): \(error.localizedDescription)")
        }

        return items
    }
}

struct ImageItem: Identifiable, Hashable {
    let id = UUID()
    let image: UIImage
    let fileName: String
}


struct ImageDetailView: View {
    let imageItem: ImageItem
    @State private var products: [Product] = []
    @State private var isFavorite = false
    @State private var lookId: Int? = nil

    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                Image(uiImage: imageItem.image)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(maxWidth: 200)
                    .cornerRadius(12)
                    .padding()

                if products.isEmpty {
                    Text("–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–¥—É–∫—Ç–∞—Ö")
                        .foregroundColor(.secondary)
                } else {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("–ü—Ä–æ–¥—É–∫—Ç—ã –≤ –æ–±—Ä–∞–∑–µ:")
                            .font(.headline)

                        ForEach(products) { product in
                            VStack(alignment: .leading, spacing: 4) {
                                Text("üõç \(product.name)")
                                    .font(.subheadline)
                                    .bold()
                                Text("üé® –¶–≤–µ—Ç: \(product.color)")
                                Text("üí∞ –¶–µ–Ω–∞: \(product.price)")
                                Text("üè¨ –ú–∞–≥–∞–∑–∏–Ω: \(product.store)")
                                Link("üîó –ü–µ—Ä–µ–π—Ç–∏", destination: URL(string: product.url)!)
                            }
                            .padding()
                            .background(Color(.systemGray6))
                            .cornerRadius(10)
                        }
                    }
                    .padding(.horizontal)
                }

                Spacer()
            }
        }
        .navigationTitle("–û–±—Ä–∞–∑")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: {
                    toggleFavorite()
                }) {
                    Image(systemName: isFavorite ? "heart.fill" : "heart")
                        .foregroundColor(isFavorite ? .red : .gray)
                }
            }
        }
        .onAppear {
            loadProducts()
            checkIfFavorite()
        }
    }

    private func loadProducts() {
        let idString = imageItem.fileName.components(separatedBy: ".").first ?? ""
        if let id = Int(idString) {
            self.lookId = id
            self.products = DatabaseManager.shared.fetchProducts(forLookId: id)
        }
    }

    private func checkIfFavorite() {
        let idString = imageItem.fileName.components(separatedBy: ".").first ?? ""
        guard let id = Int(idString) else { return }

        APIService.shared.fetchFavorites { result in
            DispatchQueue.main.async {
                switch result {
                case .success(let favorites):
                    self.isFavorite = favorites.contains(id)
                case .failure(let error):
                    print(" –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func toggleFavorite() {
        guard let id = lookId else { return }

        if isFavorite {
            //–£–¥–∞–ª—è–µ–º –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
            APIService.shared.removeFavorite(outfitId: id) { result in
                DispatchQueue.main.async {
                    switch result {
                    case .success(let _):
                        self.isFavorite = false
                    case .failure(let error):
                        print("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ: \(error.localizedDescription)")
                    }
                }
            }
        } else {
            //–î–æ–±–∞–≤–ª—è–µ–º –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ
            APIService.shared.addFavorite(outfitId: id) { result in
                DispatchQueue.main.async {
                    switch result {
                    case .success(let _):
                        self.isFavorite = true
                    case .failure(let error):
                        print("–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ: \(error.localizedDescription)")
                    }
                }
            }
        }
    }


}



//struct ImageItem: Identifiable, Hashable {
//    let id = UUID()
//    let image: UIImage
//    let fileName: String
//}





struct ProfileView: View {
    @State private var user: User?
    @State private var isLoggedOut = false
    @State private var errorMessage = ""

    var body: some View {
        VStack(spacing: 20) {
            if let user = user {
                // –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                VStack(alignment: .leading, spacing: 10) {
                    Text("üë§ \(user.name)")
//                        .font(.title2)
//                        .bold()
                    Text("üìß \(user.email)")
//                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()

                // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
                Divider()
                    .background(Color.gray)

                // –°–µ–∫—Ü–∏—è "–ö–æ–Ω—Ç–∞–∫—Ç—ã"
                VStack(alignment: .leading, spacing: 10) {
                    Text("–ö–æ–Ω—Ç–∞–∫—Ç—ã")
                        .font(.headline)
                        .padding(.bottom, 5)
                    Text("–ü—Ä–∏ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–∏ –ø—Ä–æ–±–ª–µ–º –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å: ")
//                        .font(.headline)
                        .padding(.bottom, 5)

                    HStack {
                        Image(systemName: "envelope")
                            .foregroundColor(.blue)
                        Text("example@gmail.com")
                            .foregroundColor(.blue)
                    }

                    HStack {
                        Image(systemName: "paperplane")
                            .foregroundColor(.purple)
                        Text("@exampleTelegram")
                            .foregroundColor(.purple)
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()

                Spacer()

                Button(action: {
                    logout()
                }) {
                    Text("–í—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.red)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
                .padding([.leading, .trailing, .bottom])

                NavigationLink(destination: LoginView(), isActive: $isLoggedOut) {
                    EmptyView()
                }
            } else if !errorMessage.isEmpty {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .padding()
                Spacer()
            } else {
                ProgressView("–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è...")
                Spacer()
            }
        }
        .padding()
        .navigationTitle("–ü—Ä–æ—Ñ–∏–ª—å")
        .onAppear {
            loadProfile()
        }
    }

    func loadProfile() {
        APIService.shared.fetchProfile { result in
            DispatchQueue.main.async {
                switch result {
                case .success(let fetchedUser):
                    self.user = fetchedUser
                case .failure(let error):
                    self.errorMessage = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è: \(error.localizedDescription)"
                }
            }
        }
    }

    func logout() {
        UserDefaults.standard.removeObject(forKey: "access_token")
        isLoggedOut = true
    }
}




struct OutfitsView: View {
    @State private var favoriteImageItems: [ImageItem] = []
    @State private var isLoading = true
    @State private var selectedImageItem: ImageItem? = nil
    @State private var colorType: String = ""

    var body: some View {
        NavigationView {
            Group {
                if isLoading {
                    ProgressView("–ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ...")
                } else if favoriteImageItems.isEmpty {
                    VStack {
                        Spacer()
                        Text("–ó–¥–µ—Å—å –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤–∞—à–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ–±—Ä–∞–∑—ã")
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                        Spacer()
                    }
                } else {
                    ScrollView {
                        LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 16) {
                            ForEach(favoriteImageItems, id: \.fileName) { item in
                                Button(action: {
                                    selectedImageItem = item
                                }) {
                                    Image(uiImage: item.image)
                                        .resizable()
                                        .scaledToFill()
                                        .frame(width: getGridItemWidth(), height: getGridItemHeight())
                                        .clipped()
                                        .cornerRadius(10)
                                }
                            }
                        }
                        .padding()
                    }



                }
            }
            .navigationTitle("–ò–∑–±—Ä–∞–Ω–Ω–æ–µ")
            .navigationBarItems(trailing:
                NavigationLink(destination: ProfileView()) {
                    Image(systemName: "person.circle")
                        .font(.title)
                }
            )
            .sheet(item: $selectedImageItem) { item in
                NavigationView {
                    ImageDetailView(imageItem: item)
                }
            }
        }
        .onAppear {
            loadFavorites()
        }
    }
    
    private func getGridItemWidth() -> CGFloat {
        let screenWidth = UIScreen.main.bounds.width
        let spacing: CGFloat = 16 * 3
        return (screenWidth - spacing) / 2
    }

    private func getGridItemHeight() -> CGFloat {
        return getGridItemWidth() * 4 / 3
    }



    private func loadFavorites() {
        isLoading = true

        APIService.shared.fetchColorType { result in
            DispatchQueue.main.async {
                switch result {
                case .success(let response):
                    self.colorType = response.color_type.lowercased()
                    fetchFavoriteIDs()
                case .failure(let error):
                    print("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è colorType: \(error.localizedDescription)")
                    self.isLoading = false
                }
            }
        }
    }

    private func fetchFavoriteIDs() {
        APIService.shared.fetchFavorites { result in
            DispatchQueue.main.async {
                switch result {
                case .success(let ids):
                    self.favoriteImageItems = loadImagesByIDs(ids: ids, folderName: self.colorType)
                case .failure(let error):
                    print("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ: \(error.localizedDescription)")
                    self.favoriteImageItems = []
                }
                self.isLoading = false
            }
        }
    }
    private func loadImagesByIDs(ids: [Int], folderName: String) -> [ImageItem] {
        var items: [ImageItem] = []

        guard let resourcePath = Bundle.main.resourcePath else {
            print("–ù–µ –Ω–∞–π–¥–µ–Ω –ø—É—Ç—å –∫ —Ä–µ—Å—É—Ä—Å–∞–º")
            return []
        }

        let folderPath = "\(resourcePath)/looks/\(folderName)"

        do {
            let fileManager = FileManager.default
            let imagePaths = try fileManager.contentsOfDirectory(atPath: folderPath)

            for id in ids {
                // –ò—â–µ–º —Ñ–∞–π–ª, –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ –µ—Å—Ç—å ID
                if let fileName = imagePaths.first(where: { $0.contains("\(id)") }) {
                    let fullPath = "\(folderPath)/\(fileName)"
                    if let image = UIImage(contentsOfFile: fullPath) {
                        let item = ImageItem(image: image, fileName: fileName)
                        items.append(item)
                    } else {
                        print("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: \(fileName)")
                    }
                } else {
                    print(" –§–∞–π–ª —Å ID \(id) –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–∞–ø–∫–µ \(folderName)")
                }
            }
        } catch {
            print(" –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ø–∞–ø–∫–∏: \(error.localizedDescription)")
        }

        return items
    }


}






struct WardrobeView: View {
    @State private var wardrobeItems: [WardrobeItem] = []
    @State private var selectedItem: WardrobeItem? = nil
    @State private var selectedPickerItem: PhotosPickerItem? = nil
    @State private var pendingImage: UIImage? = nil
    @State private var showConfirmationSheet = false
    @State private var showInvalidAspectRatioAlert = false
    
//    @State private var selectedPickerItem: PhotosPickerItem? = nil
    

    // –í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞ –∏ —Ç–∏–ø–∞
    @State private var selectedColor: ClothingColor? = nil
    @State private var selectedType: ClothingType? = nil

    let imagesFolderName = "WardrobeImages"
    private let requiredAspectRatio: CGFloat = 1.0 / 1.0

    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 115))], spacing: 16) {
                    ForEach(wardrobeItems) { item in
                        if let image = item.getImage() {
                            Button(action: {
                                selectedItem = item
                            }) {
                                Image(uiImage: image)
                                    .resizable()
                                    .scaledToFill()
                                    .frame(width: 115, height: 115)
                                    .clipped()
                                    .cornerRadius(8)
                            }
                        }
                    }
                    
                    
                }
                .padding()
                
                PhotosPicker(
                    selection: $selectedPickerItem,
                    matching: .images,
                    photoLibrary: .shared()
                ) {
                    Text("–î–æ–±–∞–≤–∏—Ç—å –æ–¥–µ–∂–¥—É")
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.blue)
                        .cornerRadius(10)
                        .padding(.horizontal)
                }
                .padding(.bottom)
                .onChange(of: selectedPickerItem) { newItem in
                    Task {
                        if let newItem = newItem,
                           let data = try? await newItem.loadTransferable(type: Data.self),
                           let image = UIImage(data: data) {

                            if hasValidAspectRatio(image) {
                                DispatchQueue.main.async {
                                    pendingImage = image
                                    showConfirmationSheet = true
                                }
                            } else {
                                showInvalidAspectRatioAlert = true
                            }
                        }
                        selectedItem = nil
                    }
                }
                
            }
            .navigationTitle("–ì–∞—Ä–¥–µ—Ä–æ–±")
            .navigationBarItems(trailing:
                NavigationLink(destination: ProfileView()) {
                    Image(systemName: "person.circle")
                        .font(.title)
                }
            )
            .onAppear {
                createImagesDirectoryIfNeeded()
                loadAllImages()
            }
            .alert("–ù–µ–ø–æ–¥—Ö–æ–¥—è—â–µ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω", isPresented: $showInvalidAspectRatioAlert) {
                Button("OK", role: .cancel) { }
            } message: {
                Text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ç–æ —Å —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ–º —Å—Ç–æ—Ä–æ–Ω 1:1")
            }
            
            .sheet(isPresented: $showConfirmationSheet) {
                ConfirmationView(
                    isPresented: $showConfirmationSheet,
                    image: $pendingImage,
                    onConfirm: {
                        if let image = pendingImage {
                            saveImageAndInsertToDatabase(image: image)
                            loadAllImages()
                        }
                        pendingImage = nil
                    },
                    selectedColor: $selectedColor,
                    selectedType: $selectedType
                )
            }

            

            
            .sheet(item: $selectedItem) { item in
                NavigationStack {
                    WardrobeItemDetailView(item: item)
                }
            }


        }
        
        
    }

    //–ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ –ë–î
    private func loadAllImages() {
        let items = DatabaseManager.shared.fetchAllWardrobeItems()
        DispatchQueue.main.async {
            self.wardrobeItems = items
        }
    }

    private func saveImageAndInsertToDatabase(image: UIImage) {
        let fileName = "\(UUID().uuidString).jpg"
        let fileURL = getDocumentsDirectory().appendingPathComponent(imagesFolderName).appendingPathComponent(fileName)

        if let data = image.jpegData(compressionQuality: 0.8) {
            do {
                try data.write(to: fileURL)

                let item = WardrobeItem(
                    color: selectedColor?.name ?? "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    type: selectedType?.name ?? "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    imagePath: "\(imagesFolderName)/\(fileName)",
                    createdAt: Date()
                )

                DatabaseManager.shared.insertWardrobeItem(item)
            } catch {
                print("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: \(error)")
            }
        }
    }


    private func isValidAspectRatio(image: UIImage) -> Bool {
        let aspectRatio = image.size.width / image.size.height
        let targetRatio: CGFloat = 1.0 / 1.0
        return abs(aspectRatio - targetRatio) < 0.1
    }

    private func createImagesDirectoryIfNeeded() {
        let folderURL = getDocumentsDirectory().appendingPathComponent(imagesFolderName)
        if !FileManager.default.fileExists(atPath: folderURL.path) {
            do {
                try FileManager.default.createDirectory(at: folderURL, withIntermediateDirectories: true)
            } catch {
                print("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏: \(error)")
            }
        }
    }

    private func getDocumentsDirectory() -> URL {
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }
    

    private func hasValidAspectRatio(_ image: UIImage) -> Bool {
        let imageAspectRatio = image.size.width / image.size.height
        return abs(imageAspectRatio - requiredAspectRatio) <= 0.1
    }

}




struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
